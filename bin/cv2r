#!/usr/bin/env node

const _ = require('lodash');
const { cyan, gray, green, red, yellow } = require('chalk');
const { exec } = require('child_process');
const camelcase = require('camelcase');
const cv2r = require('../lib/cv2r');
const difficulty = require('../config/difficulty');
const os = require('os');
const patchManager = require('../lib/patch-manager');
const path = require('path');
const program = require('commander');
const { getDifficulties } = require('../lib/patch-manager');
const { log, pad, printHeader, validateRom } = require('../lib/utils');

const optionList = array => array.map(a => green(a)).join(', ');
const bin = process.platform === 'win32' ? 'node .\\bin\\cv2r' : './bin/cv2r';

let isCommand = false;

program
	.version(require('../package.json').version)
	.description(`${yellow('Castlevania II: Simon\'s Quest Randomizer')} by ${red('Blood')}${cyan('Sweat')}And${green('Code')}`)
	.usage('[options] [vanilla_rom_file]')
	.option('-d, --difficulty <difficulty>', 'difficulty setting for the game, see list below')
	.option('-j, --json', 'output patch and spoiler as json, disables all other output')
	.option('-o, --output <output>', 'filepath for randomized rom output')
	.option('-p, --palette <palette>', 'palette for the game, see list below', 'simons-quest')
	.option('-r, --run', 'immediately run with emulator after randomizing (fceux or OpenEmu must be in PATH)')
	.option('-s, --seed <seed>', 'seed to use for randomization')
	.option('-x, --patch <patches>', 'comma separated list of patches to apply, see list below')
	.option('-z, --debug', 'enable debug output');

program
	.command('patch <name> [files...]')
	.description(`create a cv2r patch

Examples:

  # create a patch by diff'ing a vanilla rom with a hacked rom
  ${bin} patch "My Patch Name" cv2.nes cv2-hacked.nes

  # create a patch from an IPS file
  ${bin} patch "My Patch Name" --method ips some-hack.ips`)
	.option('-d, --desc <desc>', 'brief description of the patch to be created')
	.option('-i, --id <id>', 'id for the patch, also used as its filename')
	.option('-m, --method <method>', `method used to create patch: ${patchManager.getPatchMethods()}`, 'diff')
	.option('-o, --output <output>', 'directory in which to store created patch', path.join(__dirname, '..', 'patch', 'optional'))
	.option('-t, --type <type>', `type of patch to create: ${patchManager.order.join(', ')}`, 'optional')
	.action(async (name, files, opts) => {
		isCommand = true;
		await patchManager.generatePatch(name, files, opts);
	});

program.outputHelp = function() {
	// make sure we don't have conflicting flags
	const found = {};
	this.options.forEach(o => {
		if (!found[o.short]) {
			found[o.short] = o;
		} else {
			throw new Error(`short flag "${o.short}" already used with option "${found[o.short].flags}"`);
		}
		if (!found[o.long]) {
			found[o.long] = o;
		} else {
			throw new Error(`long flag "${o.long}" already used with option "${found[o.long].flags}"`);
		}
	});

	// find the longest flags string in our options
	const longest = Math.max(...(this.options.map(o => o.flags.length)));
	const p = str => pad(str, longest);
	const desc = text => {
		const width = process.stdout.columns - longest - 20;
		const rx = new RegExp('.{1,' + width + '}[\\s\\r\\n\\t]', 'g');
		const lines = text.match(rx);
		lines.forEach((line, index) => {
			if (index) {
				console.log(' '.repeat(longest + 4) + line);
			} else {
				process.stdout.write(line + '\n');
			}
		});
	};

	// print help
	console.log(this.description());
	console.log('');
	console.log(cyan('Usage'));
	console.log(`  cv2r ${this.usage()}`);
	console.log('');
	console.log(cyan('Examples'));
	console.log(gray('  # Show this help'));
	console.log(`  ${bin} --help`);
	console.log('');
	console.log(gray('  # Generate a rom with the seed "BSAC" at standard difficulty'));
	console.log(`  ${bin} --seed BSAC cv2.nes`);
	console.log('');
	console.log(gray('  # Generate a rom with the seed "BurbAndSath" at hard difficulty'));
	console.log(`  ${bin} --seed BurbAndSath --difficulty hard cv2.nes`);
	console.log('');
	console.log(gray('  # Generate a rom with a random seed using the "Rondo of Burb" palette'));
	console.log(`  ${bin} --palette rondo-of-burb cv2.nes`);
	console.log('');
	console.log(gray('  # Generate a custom rom with a list of patches'));
	console.log(`  ${bin} --patch enemy-hp,hearts-patch,price-rando cv2.nes`);
	console.log('');
	console.log(cyan('Options'));
	this.options.forEach(o => console.log(`  ${p(o.flags)}  ${p(o.description)}`));
	console.log('');
	console.log(cyan('Difficulties'));
	console.log('');
	Object.keys(difficulty).forEach(key => {
		const { description, patches } = difficulty[key];
		process.stdout.write(`  ${p(key)}  `);
		desc(description);
		console.log(' '.repeat(longest + 4) + 'PATCHES: ' + green(patches.join(', ')));
		console.log('');
	});
	console.log('');
	console.log(cyan('Patches'));
	console.log('');
	patchManager.getPatches().forEach(patch => {
		console.log(`  ${p(patch.id)}  ${p(patch.short || patch.description)}`);
	});
	console.log('');
	console.log(cyan('Palettes'));
	console.log('');
	patchManager.getPatches('palette').forEach(patch => {
		console.log(`  ${p(patch.id)}  ${p(patch.description)}`);
	});
};

async function main() {
	try {
		// process command line arguments
		program.parse(process.argv);
		if (isCommand) { return; }

		if (program.debug && !program.json) {
			global.debug = true;
		}

		if (!program.difficulty && !program.patch) {
			program.difficulty = 'standard';
		}
		if (program.difficulty && program.patch) {
			throw new Error('cannot set difficulty and patch list, must be one or the other');
		}
		if (!program.patch && !getDifficulties().includes(program.difficulty)) {
			throw new Error(`invalid difficulty, valid choices are: ${optionList(getDifficulties())}`);
		}

		const palettes = patchManager.getPatches('palette').map(p => p.id);
		if (program.palette && !palettes.includes(program.palette)) {
			throw new Error(`invalid palette, valid choices are: ${optionList(palettes)}`);
		}
		// eslint-disable-next-line
		program.rom = program.args[0];
		if (program.rom) { validateRom(program.rom); }

		printHeader('options');
		const opts = _.pick(program, program.options.map(o => camelcase(o.long)).concat('rom'));
		opts.version = program.version();
		log(opts);
		log('');

		// create the rando based on command line options and config.json
		const outputLog = msg => !opts.json && console.log(msg);
		const output = await cv2r(program);
		outputLog(`CV2 Randomizer ${green('successful!')}`);
		outputLog(`* rom:     ${cyan(output.rom)}`);
		outputLog(`* patch:   ${cyan(output.patch)}`);
		outputLog(`* spoiler: ${cyan(output.spoiler)}`);

		// run the rom, if necessary
		if (program.run) {
			const cmd = os.platform() === 'darwin' ?
				`open -a OpenEmu ${output.rom}` :
				`fceux ${output.rom}`;
			outputLog('');
			outputLog(`Launching randomized rom with ${cyan(cmd)}`);
			exec(cmd);
		}
	} catch (err) {
		console.error(red('### CV2 Randomizer creation failed ###'));
		console.log(red(err.stack));
		process.exit(1);
	}
}

main();
